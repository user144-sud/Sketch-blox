<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sketch-Blox 2D: Balanced Edition</title>
    <style>
        :root {
            --cursor-img: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path d="M2,2 L18,12 L12,14 L18,24 L14,26 L8,16 L4,20 Z" fill="white" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>');
        }

        body {
            margin: 0; background-color: #fff; font-family: 'Courier New', Courier, monospace;
            display: flex; align-items: center; justify-content: center; height: 100vh;
            overflow: hidden; cursor: var(--cursor-img) 2 2, auto; user-select: none;
        }

        #game-wrapper { position: relative; border: 5px solid #000; background: white; box-shadow: 15px 15px 0px #000; }
        canvas { display: block; background-color: #fff; max-width: 100vw; max-height: 80vh; }

        .ui-panel { position: absolute; top: 15px; left: 15px; display: none; flex-direction: column; gap: 8px; z-index: 5; }
        button { background: #fff; border: 3px solid #000; padding: 10px 15px; font-weight: bold; font-family: inherit; cursor: var(--cursor-img) 2 2, pointer; }
        button:hover { background: #000; color: #fff; }

        .menu { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; border: 5px solid #000; padding: 20px; text-align: center; z-index: 10; min-width: 300px; }
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 10px; }
        .scroll { max-height: 200px; overflow-y: auto; border: 2px solid #000; padding: 5px; }

        #mobile-controls { position: absolute; bottom: 30px; left: 0; width: 100%; display: none; justify-content: space-between; padding: 0 40px; box-sizing: border-box; pointer-events: none; }
        .m-btn { width: 65px; height: 65px; background: white; border: 4px solid #000; display: flex; align-items: center; justify-content: center; font-weight: bold; pointer-events: auto; }

        #build-tools { position: absolute; top: 15px; right: 15px; display: none; flex-direction: column; gap: 5px; z-index: 6; }
        .active-tool { background: #000 !important; color: #fff !important; }
    </style>
</head>
<body>

<div id="game-wrapper">
    <canvas id="gameCanvas"></canvas>

    <div id="build-tools">
        <button id="tool-plat" class="active-tool" onclick="setTool('plat')">PLATFORM</button>
        <button id="tool-spike" onclick="setTool('spike')">SPIKE</button>
        <button id="tool-hole" onclick="setTool('hole')">HOLE</button>
        <button id="test-btn" onclick="togglePlaytest()" style="margin-top:10px;">PLAYTEST</button>
    </div>

    <div id="startMenu" class="menu">
        <h1 style="margin:0">SKETCH-BLOX</h1>
        <button onclick="startGame()" style="font-size: 1.5em; width: 100%;">START GAME</button>
    </div>

    <div id="winMenu" class="menu" style="display:none;">
        <h1 style="margin:0">GOAL!</h1>
        <p>Level Cleared.</p>
        <div class="grid">
            <button onclick="nextMap()">NEXT MAP</button>
            <button onclick="loadMap(currentMapName)">REPLAY</button>
        </div>
    </div>

    <div id="gameUI" class="ui-panel">
        <button onclick="toggleMenu('mapMenu')">MAPS</button>
        <button onclick="toggleMenu('avatarMenu')">AVATAR</button>
        <button onclick="toggleBuildMode()" id="buildBtn">CREATE MAPS</button>
        <button onclick="toggleMenu('settingsMenu')">SETTINGS</button>
    </div>

    <div id="mapMenu" class="menu" style="display:none;">
        <h2 style="margin:0">Worlds</h2>
        <div class="grid scroll" id="mapList"></div>
        <br><button onclick="toggleMenu('mapMenu')">CLOSE</button>
    </div>

    <div id="avatarMenu" class="menu" style="display:none;">
        <h2 style="margin:0">Hats</h2>
        <div class="grid">
            <button onclick="setHat('none')">None</button>
            <button onclick="setHat('tophat')">Top Hat</button>
            <button onclick="setHat('crown')">Crown</button>
            <button onclick="setHat('helmet')">Helmet</button>
            <button onclick="setHat('viking')">Viking</button>
            <button onclick="setHat('cap')">Cap</button>
        </div>
        <br><button onclick="toggleMenu('avatarMenu')">CLOSE</button>
    </div>

    <div id="settingsMenu" class="menu" style="display:none;">
        <h2>Settings</h2>
        <button onclick="toggleMobile()" id="mobToggle">Mobile Buttons: OFF</button>
        <br><br><button onclick="toggleMenu('settingsMenu')">CLOSE</button>
    </div>

    <div id="mobile-controls">
        <div style="display:flex; gap: 15px;">
            <div class="m-btn" id="btnL">←</div>
            <div class="m-btn" id="btnR">→</div>
        </div>
        <div class="m-btn" id="btnJ">JUMP</div>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 800; canvas.height = 450;

    const GRAVITY = 0.6;
    const JUMP_FORCE = -12;
    const SPEED = 5;

    let gameActive = false, buildMode = false, isTesting = false, buildTool = 'plat';
    let currentMapName = "Plains", activeMenu = null, mobileOn = false;

    const player = {
        x: 50, y: 300, width: 20, height: 60, velX: 0, velY: 0, grounded: false,
        hat: 'none', direction: 1, isDead: false, isWinning: false, rotation: 0, scale: 1
    };

    const keys = {};
    const mobKeys = { l: false, r: false, j: false };
    let platforms = [], spikes = [], keyhole = { x: 730, y: 360 };

    const mapNames = ["Plains", "SpikePit", "Islands", "Stairs", "Peak", "Caves", "TheBridge", "TheShaft", "ZigZag", "Gauntlet"];

    window.addEventListener('keydown', e => keys[e.code] = true);
    window.addEventListener('keyup', e => keys[e.code] = false);

    function bindMob(id, key) {
        const b = document.getElementById(id);
        const down = (e) => { e.preventDefault(); mobKeys[key] = true; };
        const up = (e) => { e.preventDefault(); mobKeys[key] = false; };
        b.addEventListener('touchstart', down); b.addEventListener('touchend', up);
        b.addEventListener('mousedown', down); b.addEventListener('mouseup', up);
    }
    bindMob('btnL', 'l'); bindMob('btnR', 'r'); bindMob('btnJ', 'j');

    canvas.addEventListener('mousedown', (e) => {
        if (!buildMode || isTesting) return;
        const rect = canvas.getBoundingClientRect();
        const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
        const my = (e.clientY - rect.top) * (canvas.height / rect.height);
        if (buildTool === 'plat') platforms.push({ x: mx - 40, y: my, w: 80, h: 15 });
        else if (buildTool === 'spike') spikes.push({ x: mx - 15, y: my - 20, w: 30, h: 30 });
        else if (buildTool === 'hole') { keyhole.x = mx; keyhole.y = my; }
    });

    function startGame() {
        document.getElementById('startMenu').style.display = 'none';
        document.getElementById('gameUI').style.display = 'flex';
        gameActive = true;
        const list = document.getElementById('mapList');
        mapNames.forEach(name => {
            let b = document.createElement('button'); b.innerText = name;
            b.onclick = () => loadMap(name); list.appendChild(b);
        });
        loadMap('Plains');
    }

    function toggleMenu(id) {
        if (activeMenu === id) { document.getElementById(id).style.display = 'none'; activeMenu = null; }
        else {
            if (activeMenu) document.getElementById(activeMenu).style.display = 'none';
            document.getElementById(id).style.display = 'block'; activeMenu = id;
        }
    }

    function toggleBuildMode() {
        buildMode = !buildMode; isTesting = false;
        document.getElementById('buildBtn').innerText = buildMode ? "EXIT BUILDER" : "CREATE MAPS";
        document.getElementById('build-tools').style.display = buildMode ? "flex" : "none";
        player.velX = 0; player.velY = 0;
    }

    function togglePlaytest() {
        isTesting = !isTesting;
        if (!isTesting) loadMap(currentMapName);
        document.getElementById('test-btn').innerText = isTesting ? "STOP TEST" : "PLAYTEST";
    }

    function setTool(t) { buildTool = t; document.querySelectorAll('#build-tools button').forEach(b => b.classList.remove('active-tool')); document.getElementById('tool-'+t).classList.add('active-tool'); }
    function setHat(h) { player.hat = h; }
    function toggleMobile() { mobileOn = !mobileOn; document.getElementById('mobile-controls').style.display = mobileOn ? 'flex' : 'none'; document.getElementById('mobToggle').innerText = "Mobile Buttons: " + (mobileOn ? "ON" : "OFF");}
    
    function nextMap() {
        let idx = mapNames.indexOf(currentMapName);
        loadMap(mapNames[(idx + 1) % mapNames.length]);
    }

    function loadMap(name) {
        currentMapName = name; platforms = []; spikes = [];
        player.x = 50; player.y = 300; player.velX = 0; player.velY = 0;
        player.isDead = false; player.isWinning = false; player.rotation = 0; player.scale = 1;
        document.getElementById('winMenu').style.display = 'none';
        
        // Default ground
        platforms.push({ x: 0, y: 410, w: 800, h: 40 });
        keyhole = { x: 740, y: 375 };

        if (name === "Plains") {
            platforms.push({ x: 350, y: 320, w: 100, h: 15 });
            spikes.push({ x: 385, y: 290, w: 30, h: 30 });
        } else if (name === "SpikePit") {
            platforms = [{ x: 0, y: 410, w: 200, h: 40 }, { x: 600, y: 410, w: 200, h: 40 }];
            platforms.push({ x: 250, y: 300, w: 80, h: 15 }, { x: 470, y: 300, w: 80, h: 15 });
            for(let i=210; i<580; i+=40) spikes.push({ x: i, y: 420, w: 30, h: 30 });
        } else if (name === "Islands") {
            platforms = [{ x: 0, y: 380, w: 150, h: 40 }]; 
            platforms.push({ x: 220, y: 320, w: 120, h: 15 }, 
                           { x: 400, y: 260, w: 120, h: 15 }, 
                           { x: 580, y: 200, w: 120, h: 15 });
            keyhole = { x: 640, y: 150 };
        } else if (name === "Stairs") {
            for(let i=1; i<6; i++) {
                platforms.push({ x: i*120, y: 410-(i*60), w: 100, h: 15 });
            }
            keyhole = { x: 650, y: 80 };
        } else if (name === "Peak") {
            platforms.push({ x: 200, y: 330, w: 400, h: 15 }, { x: 300, y: 240, w: 200, h: 15 }, { x: 375, y: 150, w: 50, h: 15 });
            spikes.push({ x: 250, y: 300, w: 30, h: 30 }, { x: 520, y: 300, w: 30, h: 30 });
            for(let i=180; i<600; i+=60) spikes.push({ x: i, y: 380, w: 30, h: 30 });
            keyhole = { x: 400, y: 110 };
        } else if (name === "Caves") {
            platforms.push({ x: 0, y: 0, w: 800, h: 40 });
            for(let i=50; i<750; i+=100) spikes.push({ x: i, y: 40, w: 30, h: 30, inv: true });
            platforms.push({ x: 150, y: 250, w: 120, h: 15 }, { x: 350, y: 320, w: 120, h: 15 }, { x: 550, y: 250, w: 120, h: 15 });
            spikes.push({ x: 400, y: 380, w: 30, h: 30 });
        } else if (name === "TheBridge") {
            platforms = [{ x: 0, y: 410, w: 100, h: 40 }, { x: 700, y: 410, w: 100, h: 40 }];
            platforms.push({x: 150, y:300, w:100, h:15}, {x: 350, y:300, w:100, h:15}, {x: 550, y:300, w:100, h:15});
            for(let i=100; i<700; i+=40) spikes.push({x: i, y:410, w:30, h:30});
        } else if (name === "TheShaft") {
            // High jump and fall challenge
            platforms = [{ x: 0, y: 410, w: 150, h: 40 }, { x: 650, y: 410, w: 150, h: 40 }];
            platforms.push({x: 100, y: 300, w: 100, h: 15}, {x: 350, y: 220, w: 100, h: 15}, {x: 600, y: 140, w: 100, h: 15}, {x: 300, y: 80, w: 200, h: 15});
            for(let i=150; i<650; i+=40) spikes.push({x: i, y: 410, w: 30, h: 30});
            keyhole = { x: 400, y: 45 };
        } else if (name === "ZigZag") {
            // Tight movement challenge
            platforms = [{ x: 0, y: 410, w: 100, h: 40 }];
            let py = 340;
            for(let i=0; i<5; i++) {
                let px = (i % 2 === 0) ? 200 : 50;
                platforms.push({x: px + (i*80), y: py, w: 120, h: 15});
                spikes.push({x: px + (i*80) + 45, y: py - 30, w: 30, h: 30});
                py -= 70;
            }
            keyhole = { x: 700, y: 80 };
        } else if (name === "Gauntlet") {
            // Long horizontal obstacle course
            platforms = [{ x: 0, y: 410, w: 100, h: 40 }, { x: 700, y: 410, w: 100, h: 40 }];
            for(let i=120; i<680; i+=140) {
                platforms.push({x: i, y: 320, w: 60, h: 15});
                spikes.push({x: i+80, y: 410, w: 30, h: 30});
                spikes.push({x: i-20, y: 410, w: 30, h: 30});
            }
            keyhole = { x: 750, y: 375 };
        }
        
        if (activeMenu) toggleMenu(activeMenu);
    }

    function drawStickman(p) {
        ctx.save();
        ctx.translate(p.x + p.width/2, p.y + p.height/2);
        ctx.rotate(p.rotation);
        ctx.scale(p.scale, p.scale);
        const headR = 10, headY = -20;
        ctx.strokeStyle = '#000'; ctx.lineWidth = 3; ctx.lineCap = 'round';
        ctx.beginPath(); ctx.arc(0, headY, headR, 0, Math.PI * 2); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, headY + headR); ctx.lineTo(0, 10); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, headY+15); ctx.lineTo(-15, headY+30); ctx.moveTo(0, headY+15); ctx.lineTo(15, headY+30); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, 10); ctx.lineTo(-10, 30); ctx.moveTo(0, 10); ctx.lineTo(10, 30); ctx.stroke();

        const hatY = headY - headR; ctx.fillStyle = "#fff"; ctx.lineWidth = 2;
        if (p.hat === 'tophat') { ctx.fillRect(-15, hatY, 30, 4); ctx.strokeRect(-15, hatY, 30, 4); ctx.fillRect(-8, hatY - 15, 16, 15); ctx.strokeRect(-8, hatY - 15, 16, 15); }
        else if (p.hat === 'crown') { ctx.beginPath(); ctx.moveTo(-10, hatY); ctx.lineTo(-10, hatY-10); ctx.lineTo(-5, hatY-5); ctx.lineTo(0, hatY-10); ctx.lineTo(5, hatY-5); ctx.lineTo(10, hatY-10); ctx.lineTo(10, hatY); ctx.closePath(); ctx.fill(); ctx.stroke(); }
        else if (p.hat === 'helmet') { ctx.beginPath(); ctx.arc(0, headY, headR+2, Math.PI, 0); ctx.stroke(); ctx.strokeRect(-10, headY, 20, 5); }
        else if (p.hat === 'viking') { ctx.beginPath(); ctx.arc(0, headY-2, headR, Math.PI, 0); ctx.stroke(); ctx.moveTo(-7, hatY); ctx.lineTo(-18, hatY-12); ctx.moveTo(7, hatY); ctx.lineTo(18, hatY-12); ctx.stroke(); }
        else if (p.hat === 'cap') { ctx.beginPath(); ctx.arc(0, headY, headR, Math.PI * 1.1, Math.PI * 1.9); ctx.stroke(); if(p.direction === 1) ctx.strokeRect(0, headY-4, 15, 3); else ctx.strokeRect(-15, headY-4, 15, 3); }
        ctx.restore();
    }

    function update() {
        if (gameActive && (!buildMode || isTesting)) {
            if (!player.isDead && !player.isWinning) {
                if (keys['ArrowRight'] || keys['KeyD'] || mobKeys.r) { player.velX = SPEED; player.direction = 1; }
                else if (keys['ArrowLeft'] || keys['KeyA'] || mobKeys.l) { player.velX = -SPEED; player.direction = -1; }
                else { player.velX *= 0.8; }
                if ((keys['Space'] || keys['ArrowUp'] || keys['KeyW'] || mobKeys.j) && player.grounded) { player.velY = JUMP_FORCE; player.grounded = false; }
                
                let dx = keyhole.x - (player.x + player.width/2), dy = keyhole.y - (player.y + player.height/2);
                let dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < 80) {
                    player.velX += dx * 0.05; player.velY += dy * 0.05;
                    if (dist < 12) { player.isWinning = true; player.velX = 0; player.velY = 0; }
                }
            }

            if (player.isWinning) {
                player.rotation += 0.25; player.scale *= 0.92;
                player.x += (keyhole.x - player.x - player.width/2) * 0.2;
                player.y += (keyhole.y - player.y - player.height/2) * 0.2;
                if (player.scale < 0.05) { document.getElementById('winMenu').style.display = 'block'; }
            } else {
                player.velY += GRAVITY; player.x += player.velX; player.y += player.velY;
                if (player.isDead) { player.rotation += 0.15; if (player.y > canvas.height + 200) loadMap(currentMapName); }
                else {
                    player.grounded = false;
                    platforms.forEach(p => { if (player.x + 5 < p.x + p.w && player.x + player.width - 5 > p.x && player.y + player.height > p.y && player.y + player.height < p.y + p.h && player.velY >= 0) { player.y = p.y - player.height; player.velY = 0; player.grounded = true; }});
                    spikes.forEach(s => { if (player.x < s.x + s.w && player.x + player.width > s.x && player.y < s.y + s.h && player.y + player.height > s.y) { player.isDead = true; player.velY = -10; player.velX = (Math.random()-0.5)*5; }});
                    if (player.y > canvas.height + 150) loadMap(currentMapName);
                }
            }
        }
        draw();
        requestAnimationFrame(update);
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (!gameActive) return;
        ctx.strokeStyle = "#000"; ctx.lineWidth = 3;
        platforms.forEach(p => { ctx.strokeRect(p.x, p.y, p.w, p.h); for (let i = 5; i < p.w; i += 15) { ctx.beginPath(); ctx.moveTo(p.x + i, p.y); ctx.lineTo(p.x + i + 10, p.y + p.h); ctx.stroke(); }});
        spikes.forEach(s => { 
            ctx.beginPath(); 
            if(s.inv) { ctx.moveTo(s.x, s.y); ctx.lineTo(s.x + s.w/2, s.y + s.h); ctx.lineTo(s.x + s.w, s.y); }
            else { ctx.moveTo(s.x, s.y + s.h); ctx.lineTo(s.x + s.w/2, s.y); ctx.lineTo(s.x + s.w, s.y + s.h); }
            ctx.closePath(); ctx.stroke(); 
        });
        
        ctx.fillStyle = "#000";
        ctx.beginPath(); ctx.arc(keyhole.x, keyhole.y - 12, 16, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.moveTo(keyhole.x - 6, keyhole.y - 6); ctx.lineTo(keyhole.x + 6, keyhole.y - 6); ctx.lineTo(keyhole.x + 18, keyhole.y + 25); ctx.lineTo(keyhole.x - 18, keyhole.y + 25); ctx.closePath(); ctx.fill();

        drawStickman(player);
    }
    update();
</script>
</body>
</html>