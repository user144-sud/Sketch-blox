<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sketch-Blox 2D: 16 Unique Worlds</title>
    <style>
        :root {
            --cursor-img: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path d="M2,2 L18,12 L12,14 L18,24 L14,26 L8,16 L4,20 Z" fill="white" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>');
        }

        body {
            margin: 0; background-color: #fff; font-family: 'Courier New', Courier, monospace;
            display: flex; align-items: center; justify-content: center; height: 100vh;
            overflow: hidden; cursor: var(--cursor-img) 2 2, auto; user-select: none;
        }

        #game-wrapper { position: relative; border: 5px solid #000; background: white; box-shadow: 15px 15px 0px #000; }
        canvas { display: block; background-color: #fff; max-width: 100vw; max-height: 80vh; }

        .ui-panel { position: absolute; top: 15px; left: 15px; display: none; flex-direction: column; gap: 8px; z-index: 5; }
        button { background: #fff; border: 3px solid #000; padding: 10px 15px; font-weight: bold; font-family: inherit; cursor: var(--cursor-img) 2 2, pointer; }
        button:hover { background: #000; color: #fff; }

        .menu { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; border: 5px solid #000; padding: 20px; text-align: center; z-index: 10; min-width: 300px; }
        
        #mobile-controls { position: absolute; bottom: 30px; left: 0; width: 100%; display: none; justify-content: space-between; padding: 0 40px; box-sizing: border-box; pointer-events: none; }
        .m-btn { width: 65px; height: 65px; background: white; border: 4px solid #000; display: flex; align-items: center; justify-content: center; font-weight: bold; pointer-events: auto; }
    </style>
</head>
<body>

<div id="game-wrapper">
    <canvas id="gameCanvas"></canvas>

    <div id="startMenu" class="menu">
        <h1 style="margin:0">SKETCH-BLOX</h1>
        <button onclick="startGame()" style="font-size: 1.5em; width: 100%;">START GAME</button>
    </div>

    <div id="gameUI" class="ui-panel">
        <button onclick="toggleMapMode()">WORLD MAP</button>
        <button onclick="toggleMenu('avatarMenu')">AVATAR</button>
        <button onclick="toggleMenu('settingsMenu')">SETTINGS</button>
    </div>

    <div id="avatarMenu" class="menu" style="display:none;">
        <h2>Hats</h2>
        <div style="display:grid; grid-template-columns: 1fr 1fr; gap:8px; margin-top:10px;">
            <button onclick="setHat('none')">None</button>
            <button onclick="setHat('tophat')">Top Hat</button>
            <button onclick="setHat('crown')">Crown</button>
            <button onclick="setHat('helmet')">Helmet</button>
            <button onclick="setHat('viking')">Viking</button>
            <button onclick="setHat('cap')">Cap</button>
        </div>
        <br><button onclick="toggleMenu('avatarMenu')">CLOSE</button>
    </div>

    <div id="settingsMenu" class="menu" style="display:none;">
        <h2>Settings</h2>
        <button onclick="toggleMobile()" id="mobToggle">Mobile Buttons: OFF</button>
        <br><br><button onclick="toggleMenu('settingsMenu')">CLOSE</button>
    </div>

    <div id="mobile-controls">
        <div style="display:flex; gap: 15px;">
            <div class="m-btn" id="btnL">←</div>
            <div class="m-btn" id="btnR">→</div>
        </div>
        <div class="m-btn" id="btnJ">JUMP</div>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 800; canvas.height = 450;

    const GRAVITY = 0.6;
    const JUMP_FORCE = -12;
    const SPEED = 5;

    let gameActive = false, isMapMode = false, unlockedLevels = [1], currentLevel = 0, mobileOn = false, activeMenu = null;

    const player = { x: 400, y: 410, width: 24, height: 64, velX: 0, velY: 0, grounded: false, hat: 'none', direction: 1, isDead: false, isWinning: false, rotation: 0, scale: 1 };

    const mapNodes = [
        { id: 1, x: 80, y: 380, next: [2] },
        { id: 2, x: 180, y: 380, next: [3] },
        { id: 3, x: 280, y: 340, next: [4] },
        { id: 4, x: 380, y: 320, next: [5, 7] }, // BRANCH POINT
        { id: 5, x: 300, y: 240, next: [6] },    // Left path (Stage 5)
        { id: 6, x: 200, y: 200, next: [9] },
        { id: 9, x: 300, y: 120, next: [11] },
        { id: 7, x: 460, y: 240, next: [8] },    // Right path (Stage 7)
        { id: 8, x: 560, y: 200, next: [10] },
        { id: 10, x: 460, y: 120, next: [11] },
        { id: 11, x: 380, y: 50, next: [12] },  
        { id: 12, x: 550, y: 50, next: [13] },
        { id: 13, x: 650, y: 120, next: [14] },
        { id: 14, x: 720, y: 200, next: [15] },
        { id: 15, x: 720, y: 300, next: [16] },
        { id: 16, x: 720, y: 400, next: [] }
    ];

    const mapScenery = [
        { type: 'mtn', x: 40, y: 410, w: 40 }, { type: 'mtn', x: 230, y: 410, w: 30 },
        { type: 'mtn', x: 520, y: 380, w: 60 }, { type: 'plat', x: 140, y: 300, w: 40 },
        { type: 'spike', x: 340, y: 410 }, { type: 'mtn', x: 740, y: 150, w: 40 }
    ];

    const mapPlayer = { x: mapNodes[0].x, y: mapNodes[0].y, targetNode: 0 };
    let platforms = [], spikes = [], keyhole = null;

    const keys = {};
    const mobKeys = { l: false, r: false, j: false };
    window.addEventListener('keydown', e => keys[e.code] = true);
    window.addEventListener('keyup', e => keys[e.code] = false);

    function bindMob(id, key) {
        const b = document.getElementById(id);
        const set = (v) => (e) => { e.preventDefault(); mobKeys[key] = v; };
        b.addEventListener('touchstart', set(true)); b.addEventListener('touchend', set(false));
    }
    bindMob('btnL', 'l'); bindMob('btnR', 'r'); bindMob('btnJ', 'j');

    canvas.addEventListener('mousedown', (e) => {
        if (!isMapMode) return;
        const rect = canvas.getBoundingClientRect();
        const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
        const my = (e.clientY - rect.top) * (canvas.height / rect.height);
        mapNodes.forEach((node, idx) => {
            const d = Math.sqrt((mx-node.x)**2 + (my-node.y)**2);
            if (d < 25 && unlockedLevels.includes(node.id)) {
                if (mapPlayer.targetNode === idx) enterLevel(node.id);
                else mapPlayer.targetNode = idx;
            }
        });
    });

    function startGame() {
        document.getElementById('startMenu').style.display = 'none';
        document.getElementById('gameUI').style.display = 'flex';
        gameActive = true;
        loadLevel(0); 
    }

    function toggleMapMode() { isMapMode = !isMapMode; if (activeMenu) toggleMenu(activeMenu); }
    function enterLevel(id) { currentLevel = id; isMapMode = false; loadLevel(id); }

    function loadLevel(id) {
        platforms = [{ x: 0, y: 410, w: 800, h: 40 }];
        spikes = []; keyhole = null;
        player.x = 50; player.y = 410; player.velX = 0; player.velY = 0;
        player.isDead = false; player.isWinning = false; player.rotation = 0; player.scale = 1;

        if (id === 0) return; // BLANK STARTING ROOM

        keyhole = { x: 740, y: 375 };
        switch(id) {
            case 1: // Unique Stage 1
                platforms.push({ x: 300, y: 310, w: 150, h: 15 });
                spikes.push({ x: 200, y: 380, w: 30, h: 30 }, { x: 360, y: 280, w: 30, h: 30 }, { x: 550, y: 380, w: 30, h: 30 });
                break;
            case 2: // Unique Stage 2
                platforms = [{ x: 0, y: 410, w: 150, h: 40 }, { x: 300, y: 410, w: 150, h: 40 }, { x: 600, y: 410, w: 200, h: 40 }];
                spikes.push({ x: 200, y: 420, w: 30, h: 30 }, { x: 500, y: 420, w: 30, h: 30 });
                break;
            case 3: // Unique Stage 3
                platforms.push({x:150, y:330, w:100, h:15}, {x:350, y:220, w:100, h:15}, {x:550, y:120, w:100, h:15});
                keyhole.x = 600; keyhole.y = 85; break;
            case 4: // Unique Stage 4
                platforms.push({x:200, y:310, w:100, h:15}, {x:500, y:310, w:100, h:15});
                spikes.push({x:385, y:380, w:30, h:30}); break;
            case 5: // Stage 5 (Left Branch)
                platforms.push({x:0, y:200, w:600, h:15});
                for(let i=100; i<500; i+=100) spikes.push({x:i, y:380, w:30, h:30});
                break;
            case 6: // Stage 6 (Left Branch)
                for(let i=1; i<5; i++) platforms.push({x:i*140, y:410-i*70, w:60, h:15});
                keyhole.x=700; keyhole.y=80; break;
            case 7: // Stage 7 (Right Branch)
                platforms = [{ x: 0, y: 410, w: 200, h: 40 }];
                platforms.push({ x: 250, y: 300, w: 80, h: 15 }, { x: 450, y: 200, w: 80, h: 15 }, { x: 650, y: 100, w: 100, h: 15 });
                keyhole.x=700; keyhole.y=65; break;
            case 8: // Stage 8 (Right Branch)
                platforms.push({x:100,y:300,w:600,h:15});
                for(let i=120; i<680; i+=80) spikes.push({x:i,y:270,w:30,h:30});
                break;
            case 9: // Stage 9 (End Left)
                platforms.push({x:150,y:340,w:80,h:10},{x:350,y:260,w:80,h:10},{x:550,y:180,w:80,h:10});
                for(let i=0; i<800; i+=50) spikes.push({x:i, y:410, w:20, h:20});
                break;
            case 10: // Stage 10 (End Right)
                platforms.push({x:50,y:250,w:100,h:15},{x:650,y:250,w:100,h:15});
                platforms.push({x:300,y:150,w:200,h:15});
                for(let i=200; i<600; i+=100) spikes.push({x:i, y:410, w:30, h:30});
                break;
            case 11: // Stage 11 (Merged)
                for(let i=100; i<700; i+=150) platforms.push({x:i, y:380-(i%200), w:40, h:15});
                break;
            case 12: // Stage 12
                platforms.push({x:0,y:150,w:150,h:15},{x:650,y:410,w:150,h:40});
                player.y=150; break;
            case 13: // Stage 13
                for(let i=0; i<5; i++) platforms.push({x:100+i*130, y:350-i*40, w:50, h:15});
                for(let i=100; i<800; i+=100) spikes.push({x:i,y:410,w:30,h:30});
                break;
            case 14: // Stage 14
                platforms.push({x:200,y:310,w:400,h:15});
                spikes.push({x:220,y:280,w:30,h:30},{x:550,y:280,w:30,h:30});
                break;
            case 15: // Stage 15
                platforms.push({x:100,y:200,w:100,h:15},{x:300,y:300,w:100,h:15},{x:500,y:200,w:100,h:15});
                break;
            case 16: // Stage 16
                platforms = [{x:0, y:410, w:60, h:40}, {x:150, y:320, w:60, h:15}, {x:320, y:230, w:60, h:15}, {x:500, y:150, w:60, h:15}, {x:650, y:240, w:60, h:15}];
                for(let i=60; i<800; i+=50) spikes.push({x:i, y:420, w:30, h:30});
                break;
        }
        if (activeMenu) toggleMenu(activeMenu);
    }

    function toggleMenu(id) {
        const m = document.getElementById(id);
        if (activeMenu === id) { m.style.display = 'none'; activeMenu = null; }
        else { if (activeMenu) document.getElementById(activeMenu).style.display = 'none'; m.style.display = 'block'; activeMenu = id; }
    }

    function setHat(h) { player.hat = h; }
    function toggleMobile() { mobileOn = !mobileOn; document.getElementById('mobile-controls').style.display = mobileOn ? 'flex' : 'none'; }

    function drawStickman(p, mapStyle = false) {
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rotation || 0); ctx.scale(p.scale || 1, p.scale || 1);
        const sc = mapStyle ? 0.5 : 1;
        const headR = 10 * sc, headY = -52 * sc; 
        ctx.strokeStyle = '#000'; ctx.lineWidth = 3 * sc; ctx.lineCap = 'round';
        ctx.beginPath(); ctx.arc(0, headY, headR, 0, Math.PI * 2); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, headY + headR); ctx.lineTo(0, -20 * sc); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, headY+headR+5*sc); ctx.lineTo(-15*sc, headY+headR+20*sc);
        ctx.moveTo(0, headY+headR+5*sc); ctx.lineTo(15*sc, headY+headR+20*sc); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, -20 * sc); ctx.lineTo(-12 * sc, 0); 
        ctx.moveTo(0, -20 * sc); ctx.lineTo(12 * sc, 0); ctx.stroke();
        const ht = headY - headR; ctx.fillStyle = "#fff"; ctx.lineWidth = 2 * sc;
        if (p.hat === 'tophat') { ctx.fillRect(-15*sc, ht, 30*sc, 4*sc); ctx.strokeRect(-15*sc, ht, 30*sc, 4*sc); ctx.fillRect(-8*sc, ht-18*sc, 16*sc, 18*sc); ctx.strokeRect(-8*sc, ht-18*sc, 16*sc, 18*sc); }
        else if (p.hat === 'crown') { ctx.beginPath(); ctx.moveTo(-12*sc, ht); ctx.lineTo(-12*sc, ht-12*sc); ctx.lineTo(-6*sc, ht-5*sc); ctx.lineTo(0, ht-12*sc); ctx.lineTo(6*sc, ht-5*sc); ctx.lineTo(12*sc, ht-12*sc); ctx.lineTo(12*sc, ht); ctx.closePath(); ctx.fill(); ctx.stroke(); }
        else if (p.hat === 'helmet') { ctx.beginPath(); ctx.arc(0, headY, headR + 2*sc, Math.PI, 0); ctx.stroke(); ctx.strokeRect(-12*sc, headY, 24*sc, 6*sc); }
        else if (p.hat === 'viking') { ctx.beginPath(); ctx.arc(0, headY-2*sc, headR, Math.PI, 0); ctx.stroke(); ctx.moveTo(-8*sc, ht); ctx.lineTo(-18*sc, ht-12*sc); ctx.moveTo(8*sc, ht); ctx.lineTo(18*sc, ht-12*sc); ctx.stroke(); }
        else if (p.hat === 'cap') { ctx.beginPath(); ctx.arc(0, headY, headR, Math.PI*1.1, Math.PI*1.9); ctx.stroke(); ctx.strokeRect(player.direction === 1 ? 0 : -18*sc, headY-4*sc, 18*sc, 3*sc); }
        ctx.restore();
    }

    function update() {
        if (!gameActive) { requestAnimationFrame(update); return; }
        if (isMapMode) {
            const target = mapNodes[mapPlayer.targetNode];
            const dx = target.x - mapPlayer.x, dy = target.y - mapPlayer.y;
            const d = Math.sqrt(dx*dx + dy*dy);
            if (d > 5) { mapPlayer.x += (dx/d)*4; mapPlayer.y += (dy/d)*4; }
        } else {
            if (!player.isDead && !player.isWinning) {
                if (keys['ArrowRight'] || keys['KeyD'] || mobKeys.r) { player.velX = SPEED; player.direction = 1; }
                else if (keys['ArrowLeft'] || keys['KeyA'] || mobKeys.l) { player.velX = -SPEED; player.direction = -1; }
                else { player.velX *= 0.8; }
                if ((keys['Space'] || keys['ArrowUp'] || keys['KeyW'] || mobKeys.j) && player.grounded) { player.velY = JUMP_FORCE; player.grounded = false; }
                if (keyhole) {
                    let dx = keyhole.x - player.x, dy = keyhole.y - (player.y - 30);
                    if (Math.sqrt(dx*dx + dy*dy) < 60) {
                        player.velX += dx * 0.05; player.velY += dy * 0.05;
                        if (Math.sqrt(dx*dx + dy*dy) < 12) { 
                            player.isWinning = true;
                            const node = mapNodes.find(n => n.id === currentLevel);
                            node.next.forEach(nxt => { if(!unlockedLevels.includes(nxt)) unlockedLevels.push(nxt); });
                        }
                    }
                }
            }
            if (player.isWinning) {
                player.rotation += 0.2; player.scale *= 0.92;
                player.x += (keyhole.x - player.x) * 0.2; player.y += (keyhole.y - (player.y - 30)) * 0.2;
                if (player.scale < 0.05) isMapMode = true;
            } else {
                player.velY += GRAVITY; player.x += player.velX; player.y += player.velY;
                if (player.isDead) { player.rotation += 0.15; if (player.y > canvas.height + 100) loadLevel(currentLevel); }
                else {
                    player.grounded = false;
                    platforms.forEach(p => {
                        if (player.x + 12 > p.x && player.x - 12 < p.x + p.w && player.y >= p.y && player.y <= p.y + 15 && player.velY >= 0) {
                            player.y = p.y; player.velY = 0; player.grounded = true;
                        }
                    });
                    spikes.forEach(s => { if (player.x + 8 > s.x && player.x - 8 < s.x + s.w && player.y > s.y && player.y - 60 < s.y + s.h) { player.isDead = true; player.velY = -10; }});
                    if (player.y > canvas.height + 50) loadLevel(currentLevel);
                }
            }
        }
        draw();
        requestAnimationFrame(update);
    }

    function draw() {
        ctx.globalAlpha = 1.0; ctx.strokeStyle = "#000"; ctx.lineWidth = 3; ctx.setLineDash([]);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (!gameActive) return;

        if (isMapMode) {
            // Map Decorations (100% Solid Black)
            ctx.lineWidth = 1.5;
            mapScenery.forEach(s => {
                ctx.beginPath();
                if(s.type === 'mtn') { ctx.moveTo(s.x, s.y); ctx.lineTo(s.x+s.w/2, s.y-s.w); ctx.lineTo(s.x+s.w, s.y); }
                else if(s.type === 'plat') { ctx.rect(s.x, s.y, s.w, 4); }
                else if(s.type === 'spike') { ctx.moveTo(s.x, s.y); ctx.lineTo(s.x+5, s.y-10); ctx.lineTo(s.x+10, s.y); }
                ctx.stroke();
            });
            // Map Path
            ctx.strokeStyle = "#ccc"; ctx.lineWidth = 2; ctx.setLineDash([5, 5]);
            mapNodes.forEach(n => { n.next.forEach(nxtId => { const nxt = mapNodes.find(x => x.id === nxtId); if (unlockedLevels.includes(nxt.id) || unlockedLevels.includes(n.id)) { ctx.beginPath(); ctx.moveTo(n.x, n.y); ctx.lineTo(nxt.x, nxt.y); ctx.stroke(); } }); });
            ctx.setLineDash([]);
            // Nodes
            mapNodes.forEach(n => {
                ctx.fillStyle = unlockedLevels.includes(n.id) ? "#fff" : "#eee";
                ctx.strokeStyle = unlockedLevels.includes(n.id) ? "#000" : "#ccc";
                ctx.lineWidth = 3; ctx.beginPath();
                for(let i=0; i<6; i++) { ctx.lineTo(n.x + Math.cos((i*Math.PI*2)/6)*22, n.y + Math.sin((i*Math.PI*2)/6)*22); }
                ctx.closePath(); ctx.fill(); ctx.stroke();
                ctx.fillStyle = unlockedLevels.includes(n.id) ? "#000" : "#ccc";
                ctx.font = "bold 14px Courier New"; ctx.textAlign = "center"; ctx.fillText(n.id, n.x, n.y + 5);
            });
            drawStickman({ x: mapPlayer.x, y: mapPlayer.y, hat: player.hat }, true);
        } else {
            // Level Rendering
            platforms.forEach(p => { ctx.strokeRect(p.x, p.y, p.w, p.h); for (let i = 5; i < p.w; i += 15) { ctx.beginPath(); ctx.moveTo(p.x+i, p.y); ctx.lineTo(p.x+i+10, p.y+p.h); ctx.stroke(); } });
            spikes.forEach(s => { ctx.beginPath(); 
                if(s.inv){ ctx.moveTo(s.x, s.y); ctx.lineTo(s.x+s.w/2, s.y+s.h); ctx.lineTo(s.x+s.w, s.y); }
                else { ctx.moveTo(s.x, s.y+s.h); ctx.lineTo(s.x+s.w/2, s.y); ctx.lineTo(s.x+s.w, s.y+s.h); }
                ctx.closePath(); ctx.stroke(); 
            });
            if (keyhole) {
                ctx.fillStyle = "#000"; ctx.beginPath(); ctx.arc(keyhole.x, keyhole.y - 12, 16, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.moveTo(keyhole.x-6, keyhole.y-6); ctx.lineTo(keyhole.x+6, keyhole.y-6); ctx.lineTo(keyhole.x+18, keyhole.y+25); ctx.lineTo(keyhole.x-18, keyhole.y+25); ctx.closePath(); ctx.fill();
            }
            drawStickman(player);
        }
    }
    update();
</script>
</body>
</html>